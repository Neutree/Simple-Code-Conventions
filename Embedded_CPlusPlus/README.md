Embedded C++ Code Conventions
==================================
*参考谷歌C++代码规范*
*草稿版本V0.1*


----------


###1 函数参数顺序
输入参数在前，输出参数在后
###2 包含文件的名词级次序
 C 库、 C++库、其他库的.h、项目内的.h 
###3 局部变量
将函数变量尽可能置于最小作用域内，在声明变量时将其初始化。尽量不要将定于放入循环中

    int i;
    i = f(); // 坏——初始化和声明分离
    nt j = g(); // 好——初始化时声明
    
    // 低效的实现
    for (int i = 0; i < 1000000; ++i) {
    Foo f; // 构造函数和析构函数分别调用 1000000 次！
    f.DoSomething(i);
    }
    
    类似变量放到循环作用域外面声明要高效的多：
    Foo f; // 构造函数和析构函数只调用 1 次
    for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
    }
### 4 明确的构造函数 
对单参数构造函数使用 C++关键字 explicit，防止隐式转换

    class Test1
    {
    public:
        Test1(int n)
        {
            num=n;
        }//普通构造函数
    private:
        int num;
    };
    class Test2
    {
    public:
        explicit Test2(int n)
        {
            num=n;
        }//explicit(显式)构造函数
    private:
        int num;
    };
    int main()
    {
        Test1 t1=12;//隐式调用其构造函数,成功
        Test2 t2=12;//编译错误,不能隐式调用其构造函数
        Test2 t2(12);//显式调用成功
        return 0;
    }
    
Test1的构造函数带一个int型的参数，代码23行会隐式转换成调用Test1的这个构造函数。而Test2的构造函数被声明为explicit（显式），这表示不能通过隐式转换来调用这个构造函数，因此代码24行会出现编译错误。
普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。

### 5 继承
使用组合通常比使用继承更合适，使用继承的话也只使用公共继承。继承通常用于两种场景：
实现继承（implementationinheritance），子类继承父类的实现代码；
接口继承（interface inheritance），子类仅继承父类的方法名称

### 6 操作符重载
一般不要重载操作符，尤其是赋值操作（operator=），应避免重载。如果需要的话，可以定义类似 Equals()、CopyFrom()等函数。

### 7 声明次序
在类中使用特定的声明次序：public:在 private:之前，成员函数在数据成员（变量）前。
定义次序如下：public:、protected:、private:，如果那一块没有，直接忽略即可。
每一块中，声明次序一般如下：
1) typedefs 和 enums；
2) 常量；
3) 构造函数；
4) 析构函数；
5) 成员函数，含静态成员函数；
6) 数据成员，含静态数据成员。

### 8 引用参数
函数形参表中，所有引用必须是 const：
void Foo(const string &in, string *out);
事实上这是一个硬性约定：输入参数为值或常数引用，输出参数为指针；输入参数可以是常数指针，但不能使用非常数引用形参。

### 9 函数重载
让函数名包含参数信息，例如，使用 AppendString() 、AppendInt()而不是 Append()。

### 10 const的使用
const 变量、数据成员、函数和参数为编译时类型检测增加了一层保障，更好的尽早发现错误。因此，我们强烈建议在任何可以使用的情况下使用 const
1) 如果函数不会修改传入的引用或指针类型的参数，这样的参数应该为 const；
2) 尽可能将函数声明为 const，访问函数应该总是 const，其他函数如果不会修改任何数据成员也应该是 const，不要调用非 const 函数，不要返回对数据成员的非 const 指针或引用；
3) 如果数据成员在对象构造之后不再改变，可将其定义为 const。

### 11 无符号整型
使用断言声明变量为非负数，不要使用无符号型。

### 12 预处理宏
使用宏时要谨慎，尽量以内联函数、枚举和常量代替之。宏意味着你和编译器看到的代码是不同的，因此可能导致异常行为，尤其是当宏存在于全局
作用域中。
宏内联 效率关键代码（ performance-criticalcode）可以内联函数替代；宏存储常量可以 const 变量替代；宏“缩写”长变量名可以引用替代；使用宏进行条件编译，这个……，最好不要这么做，会令测试更加痛苦（#define防止头文件重包含当然是个例外）。

### 13 置零
整数用 0，实数用 0.0，指针用 NULL，字符（串）用'\0'

### 14 命名规则
#### 14.1 通用命名规则
类型和变量名一般为名词：如 FileOpener、num_errors。
函数名通常是指令性的，如 OpenFile() 、 set_num_errors()，访问函数需要描述的更细致，要与其访问的变量相吻合。除非放到项目外也非常明了，否则不要使用缩写
#### 14.2 文件命名
文件名要全部小写，可以包含下划线（_）或短线（-），通常，尽量让文件名更加明确，http_server_logs.h 就比 logs.h 要好，定义类时文件名一般成对出现，如 foo_bar.h 和 foo_bar.cpp，对应类 FooBar。
#### 14.3 类型命名
类型命名每个单词以大写字母开头，不包含下划线：MyExcitingClass、MyExcitingEnum。
所有类型命名——类、结构体、类型定义（typedef）、枚举——使用相同约定，例如：

    // classes and structs
    class UrlTable { ...
    class UrlTableTester { ...
    struct UrlTableProperties { ...
    // typedefs
    typedef hash_map<UrlTableProperties *, string> PropertiesMap;
    // enums
    enum UrlTableErrors { ...

#### 14.4 变量命名
变量名一律小写，单词间以下划线相连，类的成员变量以下划线结尾

#### 14.5 常量命名
在名称前加 k：kDaysInAWeek。
所有编译时常量（无论是局部的、全局的还是类中的）和其他变量保持些许区别，k 后接大写字母开头的单词：const int kDaysInAWeek = 7;

#### 14.6 函数命名
普通函数函数名以大写字母开头，每个单词首字母大写，没有下划线：
AddTableEntry()
DeleteUrl()
存取函数要与存取的变量名匹配，全部小写，单词用下划线隔开

#### 14.7 宏命名
如果使用，像这样：MY_MACRO_THAT_SCARES_SMALL_CHILDREN

### 15 注释
#### 15.1 注释风格
使用//或/* */，统一就好。
#### 15.2 文件注释
在每一个文件开头加入版权公告，然后是文件内容描述
法律公告和作者信息：
每一文件包含以下项，依次是：
1) 版权（copyright statement）：如 Copyright 2008 Google Inc.；
2) 许可版本（license boilerplate）：为项目选择合适的许可证版本，如 Apache 2.0、
BSD、LGPL、GPL；
3) 作者（author line）：标识文件的原始作者。

如果你对其他人创建的文件做了重大修改，将你的信息添加到作者信息里，这样当其他人对该文件有疑问时可以知道该联系谁。
文件内容：
每一个文件版权许可及作者信息后，都要对文件内容进行注释说明。
通常，
.h 文件要对所声明的类的功能和用法作简单说明
.cc 文件包含了更多的实现细节或算法讨论
如果你感觉这些实现细节或算法讨论对于阅读有帮助，可以把.cc 中的注释放到.h 中，并在.cc 中指出文档在.h 中。
不要单纯在.h 和.cc 间复制注释，复制的注释偏离了实际意义。
#### 15.3 类注释
每个类的定义要附着描述类的功能和用法的注释。

#### 15.4 函数注释
函数声明处注释描述函数功能，定义处描述函数实现。
函数声明处注释的内容：
1) inputs（输入）及 outputs（输出）；
2) 对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数；
3) 如果函数分配了空间，需要由调用者释放；
4) 参数是否可以为 NULL；
5) 是否存在函数使用的性能隐忧（performance implications）；

注释构造/析构函数时，记住，读代码的人知道构造/析构函数是什么，所以“destroys thisobject”这样的注释是没有意义的。说明构造函数对参数做了什么（例如，是否是指针的所有者）以及析构函数清理了什么，如果都是无关紧要的内容，直接省掉注释，析构函数前没有注释是很正常的。

函数定义：
每个函数定义时要以注释说明函数功能和实现要点，如使用的漂亮代码、实现的简要步骤、如此实现的理由、为什么前半部分要加锁而后半部分不需要。不要从.h 文件或其他地方的函数声明处直接复制注释，简要说明函数功能是可以的，但重点要放在如何实现上。

#### 15.5 变量注释
通常变量名本身足以很好说明变量用途，特定情况下，需要额外注释说明
每个类数据成员（也叫实例变量或成员变量）应注释说明用途，如果变量可以接受 NULL 或-1等警戒值（sentinel values），须说明之

### 16 格式
尽量不使用非 ASCII 字符，使用时必须使用 UTF-8 格式
只使用空格，每次缩进 2 个空格。使用空格进行缩进，不要在代码中使用 tabs，设定编辑器将 tab 转为空格。

#### 16.1 函数声明与定义：
1) 返回值总是和函数名在同一行；
2) 左圆括号（open parenthesis）总是和函数名在同一行；
3) 函数名和左圆括号间没有空格；
4) 圆括号与参数间没有空格；
5) 左大括号（open curly brace）总在最后一个参数同一行的末尾处；
6) 右大括号（close curly brace）总是单独位于函数最后一行；
7) 右圆括号（close parenthesis）和左大括号间总是有一个空格；
8) 函数声明和实现处的所有形参名称必须保持一致；
9) 所有形参应尽可能对齐；
10) 缺省缩进为 2 个空格；
11) 独立封装的参数保持 4 个空格的缩进

#### 16.2 函数调用：
尽量放在同一行，否则，将实参封装在圆括号中。函数调用遵循如下形式：

    bool retval = DoSomething(argument1, argument2, argument3);


#### 16.3 条件语句
更提倡不在圆括号中添加空格，关键字 else 另起一行
 if 和左圆括号间有个空格，右圆括号和左大括号（如果使用的话）间也要
有个空格
如果语句中哪一分支使用了大括号的话，其他部分也必须使用
#### 16.4 循环和开关选择语句
switch 语句可以使用大括号分块；空循环体应使用{}或 continue
如果有不满足 case枚举条件的值，要总是包含一个default（如果有输入值没有 case 去处理，编译器将报警）。如果 default 永不会执行，可以简单的使用 assert：

    switch (var) {
        case 0: { // 2 space indent
         ... // 4 space indent
         break;
    }
    case 1: {
        ...
      break;
    }
        default: {
        assert(false);
        }
    }

空循环体应使用{}或 continue，而不是一个简单的分号：

    while (condition) {
    // Repeat test until it returns false.
    }

#### 16.5 指针和引用表达式
句点（.）或箭头（->）前后不要有空格，指针/地址操作符（*、&）后不要有空格。
下面是指针和引用表达式的正确范例：
x = *p;
p = &x;
x = r.y;
x = r->y;
#### 16.6 函数返回值
return 表达式中不要使用圆括号。
函数返回时不要使用圆括号：

    return x; // not return(x);


